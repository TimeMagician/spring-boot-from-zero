<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="JUnitGeneratorProjectSettings">
    <option name="outputFilePattern" value="${SOURCEPATH}/../../test/java/${PACKAGE}/${FILENAME}" />
    <option name="selectedTemplateKey" value="JUnit 4" />
    <option name="vmTemplates">
      <map>
        <entry key="JUnit 3" value="######################################################################################## &#10;## &#10;## Available variables: &#10;##         $entryList.methodList - List of method composites &#10;##         $entryList.privateMethodList - List of private method composites &#10;##         $entryList.fieldList - ArrayList of class scope field names &#10;##         $entryList.className - class name &#10;##         $entryList.packageName - package name &#10;##         $today - Todays date in MM/dd/yyyy format &#10;## &#10;##            MethodComposite variables: &#10;##                $method.name - Method Name &#10;##                $method.signature - Full method signature in String form &#10;##                $method.reflectionCode - list of strings representing commented out reflection code to access method (Private Methods) &#10;##                $method.paramNames - List of Strings representing the method's parameters' names &#10;##                $method.paramClasses - List of Strings representing the method's parameters' classes &#10;## &#10;## You can configure the output class name using &quot;testClass&quot; variable below. &#10;## Here are some examples: &#10;## Test${entry.ClassName} - will produce TestSomeClass &#10;## ${entry.className}Test - will produce SomeClassTest &#10;## &#10;######################################################################################## &#10;## &#10;#macro (cap $strIn)$strIn.valueOf($strIn.charAt(0)).toUpperCase()$strIn.substring(1)#end &#10;## Iterate through the list and generate testcase for every entry. &#10;#foreach ($entry in $entryList) &#10;#set( $testClass=&quot;${entry.className}Test&quot;) &#10;## &#10;package test.$entry.packageName; &#10;&#10;import junit.framework.Test; &#10;import junit.framework.TestSuite; &#10;import junit.framework.TestCase; &#10;&#10;/** &#10;* ${entry.className} Tester. &#10;* &#10;* @author &lt;Authors name&gt; &#10;* @since &lt;pre&gt;$today&lt;/pre&gt; &#10;* @version 1.0 &#10;*/ &#10;public class $testClass extends TestCase { &#10;public $testClass(String name) { &#10;super(name); &#10;} &#10;&#10;public void setUp() throws Exception { &#10;super.setUp(); &#10;} &#10;&#10;public void tearDown() throws Exception { &#10;super.tearDown(); &#10;} &#10;&#10;#foreach($method in $entry.methodList) &#10;/** &#10;* &#10;* Method: $method.signature &#10;* &#10;*/ &#10;public void test#cap(${method.name})() throws Exception { &#10;//TODO: Test goes here... &#10;} &#10;&#10;#end &#10;&#10;#foreach($method in $entry.privateMethodList) &#10;/** &#10;* &#10;* Method: $method.signature &#10;* &#10;*/ &#10;public void test#cap(${method.name})() throws Exception { &#10;//TODO: Test goes here... &#10;#foreach($string in $method.reflectionCode) &#10;$string &#10;#end &#10;} &#10;&#10;#end &#10;&#10;public static Test suite() { &#10;return new TestSuite(${testClass}.class); &#10;} &#10;} &#10;#end" />
        <entry key="JUnit 4" value="########################################################################################&#10;##&#10;## Available variables:&#10;##         $entryList.methodList - List of method composites&#10;##         $entryList.privateMethodList - List of private method composites&#10;##         $entryList.fieldList - ArrayList of class scope field names&#10;##         $entryList.className - class name&#10;##         $entryList.packageName - package name&#10;##         $today - Todays date in MM/dd/yyyy format&#10;##&#10;##            MethodComposite variables:&#10;##                $method.name - Method Name&#10;##                $method.signature - Full method signature in String form&#10;##                $method.reflectionCode - list of strings representing commented out reflection code to access method (Private Methods)&#10;##                $method.paramNames - List of Strings representing the method's parameters' names&#10;##                $method.paramClasses - List of Strings representing the method's parameters' classes&#10;##&#10;## You can configure the output class name using &quot;testClass&quot; variable below.&#10;## Here are some examples:&#10;## Test${entry.ClassName} - will produce TestSomeClass&#10;## ${entry.className}Test - will produce SomeClassTest&#10;##&#10;########################################################################################&#10;##&#10;#macro (cap $strIn)$strIn.valueOf($strIn.charAt(0)).toUpperCase()$strIn.substring(1)#end&#10;## Iterate through the list and generate testcase for every entry.&#10;#foreach ($entry in $entryList)&#10;#set( $testClass=&quot;${entry.className}Test&quot;)&#10;#set( $beanName=&quot;${entry.className.substring(0,1).toLowerCase()}${entry.className.substring(1)}&quot;)&#10;##&#10;package $entry.packageName;&#10;import com.github.springtestdbunit.annotation.DatabaseSetup;&#10;import com.ke.caibei.server.BaseTest;&#10;import org.junit.Test;&#10;import org.mockito.InjectMocks;&#10;import org.mockito.Mock;&#10;import org.junit.rules.ExpectedException;&#10;import org.junit.Rule;&#10;import org.junit.Assert;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.transaction.annotation.Transactional;&#10;import static org.mockito.Matchers.*;&#10;import static org.mockito.Mockito.*;&#10;/**&#10;* Tester of {@link ${entry.className}} &#10;*&#10;* @author $user&#10;* @since $today&#10;*/&#10;@Transactional&#10;public class $testClass extends BaseTest {&#10;    @Rule&#10;    public ExpectedException expectedException = ExpectedException.none();&#10;    @Autowired&#10;    @InjectMocks&#10;    ${entry.className} $beanName;&#10;#foreach($field in $entry.fieldList)&#10;    @Mock&#10;    #cap($field) $field;&#10;#end&#10; &#10;#foreach($method in $entry.methodList)&#10;    /**&#10;    * The correct expectation&#10;    *&#10;    * @see ${entry.className}#$method.signature &#10;    */&#10;    @Test&#10;    @DatabaseSetup(&quot;/data.json&quot;)&#10;    public void shouldSuccessWhen#cap(${method.name})With_() {&#10;        //you can get some expect results by use Mockito.when().then() like this&#10;        //when(mockField.getSomething(anyString())).thenReturn(someResult);&#10;        Object result = ${beanName}.${method.name}();&#10;        Assert.assertNotNull(result);&#10;    }&#10;    /**&#10;    * The error expectation&#10;    *&#10;    * @see ${entry.className}#$method.signature&#10;    */&#10;    @Test&#10;    @DatabaseSetup(&quot;/data.json&quot;)&#10;    public void shouldThrowExceptionWhen#cap(${method.name})With_() {&#10;        //message is the expect error message&#10;        //eg. BizCodes.PRODUCT_ID_CANNOT_EMPTY.getMessage();&#10;        //you can also use expectedException.expect(Class&lt;? extends Throwable&gt; type);&#10;        expectedException.expectMessage(&quot;&quot;);&#10;        ${beanName}.${method.name}();&#10;    }&#10;#end&#10;}&#10;#end" />
      </map>
    </option>
  </component>
</project>